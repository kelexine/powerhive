#!/system/bin/sh
# PowerHive - Advanced Power Management for Android
# Author: Kelexine
# Version: 1.0.0

# Color definitions
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
CYAN="\033[0;36m"
GOLD="\033[38;5;214m"
NC="\033[0m" # No Color

# ASCII art for beehive themed header
HEADER="
${GOLD}    ___                      _  _ _
${GOLD}   | _ \ ___ _ __ _____ _ _ | || (_)_ _____
${GOLD}   |  _// _ \ \ // / -_) '_|| __ | \ V / -_)
${GOLD}   |_|  \___/_\_\\_\___|_|  |_||_|_|\_/\___|
${YELLOW}    ⬡   ⬡   ⬡   ⬡   ⬡   ⬡   ⬡   ⬡   ⬡   ⬡
${NC}"

# Configuration file path
CONFIG_FILE="/data/powerhive/config.json"
BACKUP_DIR="/data/powerhive/backups"

# Check if running as root
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        echo -e "${RED}Error: PowerHive must run as root${NC}"
        echo "Try: su -c powerhive"
        exit 1
    fi
}

# Initialize configuration directories and files
initialize() {
    if [ ! -d "/data/powerhive" ]; then
        mkdir -p "/data/powerhive"

        # Create default configuration (This part is now handled by customize.sh on first install)
        # However, keeping it here allows the script to function standalone if needed,
        # or in case the customize.sh logic fails.
        if [ ! -f "$CONFIG_FILE" ]; then
           echo '{
  "active_mode": "normal",
  "modes": {
    "normal": {
      "cpu_governor": "schedutil",
      "background_limit": 32,
      "max_cpu_freq": "auto"
    },
    "turbo": {
      "cpu_governor": "performance",
      "background_limit": 64,
      "max_cpu_freq": "max"
    },
    "battery": {
      "cpu_governor": "powersave",
      "background_limit": 16,
      "max_cpu_freq": "min"
    }
  },
  "smart_mode": {
    "enabled": false,
    "conditions": {
      "battery_low": 20,
      "battery_high": 80
    }
  }
}' > "$CONFIG_FILE"
        fi
    fi

    # Create backup directory
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# Read current configuration
read_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${RED}Error: Configuration file not found${NC}"
        exit 1
    fi

    ACTIVE_MODE=$(grep -o '"active_mode": *"[^"]*"' "$CONFIG_FILE" | cut -d'"' -f4)
}

# Log function for consistent formatting
log_action() {
    echo -e "[$(date +"%Y-%m-%d %H:%M:%S")] ${BLUE}$1${NC}" >> "/data/powerhive/powerhive.log"
    echo -e "${BLUE}$1${NC}"
}

# Apply power mode settings
apply_mode() {
    local mode=$1

    # Extract settings from config
    local cpu_governor=$(grep -o "\"$mode\".*\"cpu_governor\": *\"[^\"]*\"" "$CONFIG_FILE" | grep -o "\"cpu_governor\": *\"[^\"]*\"" | cut -d'"' -f4)
    local background_limit=$(grep -o "\"$mode\".*\"background_limit\": *[0-9]*" "$CONFIG_FILE" | grep -o "\"background_limit\": *[0-9]*" | grep -o "[0-9]*")
    local max_cpu_freq=$(grep -o "\"$mode\".*\"max_cpu_freq\": *\"[^\"]*\"" "$CONFIG_FILE" | grep -o "\"max_cpu_freq\": *\"[^\"]*\"" | cut -d'"' -f4)

    # Apply CPU governor to all cores
    for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
        if [ -f "$cpu" ]; then
            echo "$cpu_governor" > "$cpu" 2>/dev/null || true
        fi
    done

    # Apply background process limit
    if command -v settings >/dev/null 2>&1; then
        settings put global activity_manager_constants "max_cached_processes=$background_limit"
    fi

    # Apply CPU frequency limits based on setting
    if [ "$max_cpu_freq" = "max" ]; then
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq; do
            if [ -f "$cpu" ]; then
                max_available=$(cat "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq")
                echo "$max_available" > "$cpu" 2>/dev/null || true
            fi
        done
    elif [ "$max_cpu_freq" = "min" ]; then
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq; do
            if [ -f "$cpu" ]; then
                min_available=$(cat "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq")
                middle_freq=$(( ($(cat "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq") + min_available) / 2 ))
                echo "$middle_freq" > "$cpu" 2>/dev/null || true
            fi
        done
    fi

    # Update active mode in config
    sed -i "s/\"active_mode\": *\"[^\"]*\"/\"active_mode\": \"$mode\"/" "$CONFIG_FILE"

    log_action "Applied power mode: $mode"
}

# Display battery status
show_battery_status() {
    if [ -f "/sys/class/power_supply/battery/capacity" ]; then
        BATT_LEVEL=$(cat /sys/class/power_supply/battery/capacity)
        BATT_STATUS=$(cat /sys/class/power_supply/battery/status)

        # Determine color based on battery level
        if [ "$BATT_LEVEL" -lt 20 ]; then
            BATT_COLOR=$RED
        elif [ "$BATT_LEVEL" -lt 50 ]; then
            BATT_COLOR=$YELLOW
        else
            BATT_COLOR=$GREEN
        fi

        echo -e "${BATT_COLOR}Battery Level: ${BATT_LEVEL}%${NC}"
        echo -e "${CYAN}Status: ${BATT_STATUS}${NC}"
    else
        echo -e "${YELLOW}Battery information not available${NC}"
    fi
}

# Backup current configuration
backup_config() {
    local backup_file="${BACKUP_DIR}/powerhive_backup_$(date +%Y%m%d_%H%M%S).json"
    cp "$CONFIG_FILE" "$backup_file"

    if [ -f "$backup_file" ]; then
        log_action "Configuration backup created: $backup_file"
        return 0
    else
        echo -e "${RED}Backup failed${NC}"
        return 1
    fi
}

# Restore configuration from backup
restore_config() {
    # List available backups
    local backups=($(ls -1 "${BACKUP_DIR}/"*.json 2>/dev/null))

    if [ ${#backups[@]} -eq 0 ]; then
        echo -e "${YELLOW}No backups found${NC}"
        return 1
    fi

    echo "Available backups:"
    for i in "${!backups[@]}"; do
        local filename=$(basename "${backups[$i]}")
        echo "  $((i+1)). $filename"
    done

    echo -n "Select backup to restore (1-${#backups[@]}, 0 to cancel): "
    read -r selection

    if [ "$selection" -gt 0 ] && [ "$selection" -le "${#backups[@]}" ]; then
        local backup_file="${backups[$((selection-1))]}"
        cp "$backup_file" "$CONFIG_FILE"
        log_action "Configuration restored from: $(basename "$backup_file")"

        # Apply the restored mode
        read_config
        apply_mode "$ACTIVE_MODE"
    elif [ "$selection" -ne 0 ]; then
        echo -e "${RED}Invalid selection${NC}"
    fi
}

# Edit specific mode settings
edit_mode_settings() {
    local mode=$1

    echo -e "${GOLD}Editing settings for ${mode} mode:${NC}"

    # Get current settings
    local curr_governor=$(grep -o "\"$mode\".*\"cpu_governor\": *\"[^\"]*\"" "$CONFIG_FILE" | grep -o "\"cpu_governor\": *\"[^\"]*\"" | cut -d'"' -f4)
    local curr_bg_limit=$(grep -o "\"$mode\".*\"background_limit\": *[0-9]*" "$CONFIG_FILE" | grep -o "\"background_limit\": *[0-9]*" | grep -o "[0-9]*")
    local curr_max_freq=$(grep -o "\"$mode\".*\"max_cpu_freq\": *\"[^\"]*\"" "$CONFIG_FILE" | grep -o "\"max_cpu_freq\": *\"[^\"]*\"" | cut -d'"' -f4)

    # Select CPU governor
    echo -e "${CYAN}Available CPU Governors:${NC}"
    echo "1. schedutil (balanced)"
    echo "2. performance (maximum performance)"
    echo "3. powersave (maximum battery saving)"
    echo "4. ondemand (dynamic scaling)"
    echo "5. keep current ($curr_governor)"

    echo -n "Select CPU governor (1-5): "
    read -r gov_selection

    case $gov_selection in
        1) new_governor="schedutil" ;;
        2) new_governor="performance" ;;
        3) new_governor="powersave" ;;
        4) new_governor="ondemand" ;;
        *) new_governor="$curr_governor" ;;
    esac

    # Input background process limit
    echo -e "${CYAN}Background process limit (current: $curr_bg_limit):${NC}"
    echo -n "Enter new limit (8-64, or 0 to keep current): "
    read -r bg_limit

    if [ "$bg_limit" -ge 8 ] && [ "$bg_limit" -le 64 ]; then
        new_bg_limit=$bg_limit
    else
        new_bg_limit=$curr_bg_limit
    fi

    # Select max CPU frequency
    echo -e "${CYAN}CPU Frequency Control:${NC}"
    echo "1. auto (system default)"
    echo "2. max (maximum performance)"
    echo "3. min (power saving)"
    echo "4. keep current ($curr_max_freq)"

    echo -n "Select max CPU frequency option (1-4): "
    read -r freq_selection

    case $freq_selection in
        1) new_max_freq="auto" ;;
        2) new_max_freq="max" ;;
        3) new_max_freq="min" ;;
        *) new_max_freq="$curr_max_freq" ;;
    esac

    # Update configuration
    sed -i "s/\"$mode\".*\"cpu_governor\": *\"[^\"]*\"/\"$mode\": {\n      \"cpu_governor\": \"$new_governor\"/" "$CONFIG_FILE"
    sed -i "s/\"background_limit\": *[0-9]*/\"background_limit\": $new_bg_limit/" "$CONFIG_FILE"
    sed -i "s/\"max_cpu_freq\": *\"[^\"]*\"/\"max_cpu_freq\": \"$new_max_freq\"/" "$CONFIG_FILE"

    log_action "Updated settings for $mode mode"
}

# Configure smart mode
configure_smart_mode() {
    # Get current settings
    local enabled=$(grep -o '"smart_mode".*"enabled": *\(true\|false\)' "$CONFIG_FILE" | grep -o '"enabled": *\(true\|false\)' | grep -o '\(true\|false\)')
    local battery_low=$(grep -o '"battery_low": *[0-9]*' "$CONFIG_FILE" | grep -o '[0-9]*')
    local battery_high=$(grep -o '"battery_high": *[0-9]*' "$CONFIG_FILE" | grep -o '[0-9]*')

    echo -e "${GOLD}Smart Mode Configuration:${NC}"
    echo -e "Current status: ${CYAN}$([ "$enabled" = "true" ] && echo "Enabled" || echo "Disabled")${NC}"

    echo -n "Enable Smart Mode? (y/n): "
    read -r smart_choice

    if [ "$smart_choice" = "y" ] || [ "$smart_choice" = "Y" ]; then
        new_enabled="true"

        echo -e "${CYAN}Configure battery thresholds:${NC}"
        echo -n "Enter battery low threshold [1-40] (current: $battery_low): "
        read -r new_low

        if [ "$new_low" -ge 1 ] && [ "$new_low" -le 40 ]; then
            battery_low=$new_low
        fi

        echo -n "Enter battery high threshold [60-100] (current: $battery_high): "
        read -r new_high

        if [ "$new_high" -ge 60 ] && [ "$new_high" -le 100 ]; then
            battery_high=$new_high
        fi
    else
        new_enabled="false"
    fi

    # Update configuration
    sed -i "s/\"enabled\": *\(true\|false\)/\"enabled\": $new_enabled/" "$CONFIG_FILE"
    sed -i "s/\"battery_low\": *[0-9]*/\"battery_low\": $battery_low/" "$CONFIG_FILE"
    sed -i "s/\"battery_high\": *[0-9]*/\"battery_high\": $battery_high/" "$CONFIG_FILE"

    log_action "Smart Mode configuration updated"

    # Start smart mode service if enabled
    if [ "$new_enabled" = "true" ]; then
        echo -e "${GREEN}Starting Smart Mode service${NC}"
        nohup sh -c "powerhive --smart-mode-service" >/dev/null 2>&1 &
    fi
}

# Smart mode service implementation
run_smart_mode_service() {
    log_action "Smart Mode service started"

    while true; do
        # Check if smart mode is still enabled
        enabled=$(grep -o '"smart_mode".*"enabled": *\(true\|false\)' "$CONFIG_FILE" | grep -o '"enabled": *\(true\|false\)' | grep -o '\(true\|false\)')

        if [ "$enabled" != "true" ]; then
            log_action "Smart Mode service stopped: disabled in settings"
            exit 0
        fi

        # Read thresholds
        battery_low=$(grep -o '"battery_low": *[0-9]*' "$CONFIG_FILE" | grep -o '[0-9]*')
        battery_high=$(grep -o '"battery_high": *[0-9]*' "$CONFIG_FILE" | grep -o '[0-9]*')

        # Read current battery level
        if [ -f "/sys/class/power_supply/battery/capacity" ]; then
            battery_level=$(cat /sys/class/power_supply/battery/capacity)
            charging_status=$(cat /sys/class/power_supply/battery/status)

            # Determine appropriate mode
            if [ "$charging_status" = "Charging" ] || [ "$charging_status" = "Full" ]; then
                # While charging, use normal or turbo based on battery level
                if [ "$battery_level" -ge "$battery_high" ]; then
                    target_mode="turbo"
                else
                    target_mode="normal"
                fi
            else
                # While discharging
                if [ "$battery_level" -le "$battery_low" ]; then
                    target_mode="battery"
                elif [ "$battery_level" -ge "$battery_high" ]; then
                    target_mode="normal"
                fi
                # If between thresholds, don't change
            fi

            # Apply mode if it's different from current
            current_mode=$(grep -o '"active_mode": *"[^"]*"' "$CONFIG_FILE" | cut -d'"' -f4)
            if [ -n "$target_mode" ] && [ "$target_mode" != "$current_mode" ]; then
                log_action "Smart Mode switching to: $target_mode (Battery: $battery_level%, Status: $charging_status)"
                apply_mode "$target_mode"
            fi
        fi

        # Sleep for 60 seconds before checking again
        sleep 60
    done
}

# Check system performance stats
check_performance() {
    echo -e "${GOLD}System Performance Stats:${NC}"
    echo -e "${CYAN}CPU Usage:${NC}"
    top -bn1 | head -n 5

    echo -e "\n${CYAN}Memory Usage:${NC}"
    free -m

    echo -e "\n${CYAN}Current CPU Governor:${NC}"
    cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

    echo -e "\n${CYAN}CPU Frequency:${NC}"
    for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq; do
        if [ -f "$cpu" ]; then
            cpu_num=$(echo "$cpu" | grep -o "cpu[0-9]*" | grep -o "[0-9]*")
            freq=$(cat "$cpu")
            freq_mhz=$(echo "scale=2; $freq/1000" | bc)
            echo "CPU$cpu_num: ${freq_mhz}MHz"
        fi
    done
}

# Display main menu and process user input
show_menu() {
    clear
    echo -e "$HEADER"

    read_config
    echo -e "${CYAN}Active Power Mode: ${GOLD}${ACTIVE_MODE}${NC}"
    show_battery_status

    echo -e "\n${YELLOW}┌──────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│            MAIN MENU                  │${NC}"
    echo -e "${YELLOW}└──────────────────────────────────────┘${NC}"
    echo -e "  ${GOLD}1.${NC} Switch to Normal Mode"
    echo -e "  ${GOLD}2.${NC} Switch to Turbo Mode (Performance)"
    echo -e "  ${GOLD}3.${NC} Switch to Battery Saver Mode"
    echo -e "  ${GOLD}4.${NC} Configure Smart Mode"
    echo -e "  ${GOLD}5.${NC} Advanced Settings"
    echo -e "  ${GOLD}6.${NC} Backup/Restore Settings"
    echo -e "  ${GOLD}7.${NC} Check System Performance"
    echo -e "  ${GOLD}8.${NC} About PowerHive"
    echo -e "  ${GOLD}0.${NC} Exit"

    echo -e "\n${CYAN}Enter your choice:${NC} "
    read -r choice

    case $choice in
        1)
            apply_mode "normal"
            log_action "Manually switched to Normal mode"
            ;;
        2)
            apply_mode "turbo"
            log_action "Manually switched to Turbo mode"
            ;;
        3)
            apply_mode "battery"
            log_action "Manually switched to Battery Saver mode"
            ;;
        4)
            configure_smart_mode
            ;;
        5)
            show_advanced_menu
            ;;
        6)
            show_backup_menu
            ;;
        7)
            check_performance
            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        8)
            show_about
            ;;
        0)
            echo -e "${GREEN}Thank you for using PowerHive!${NC}"
            exit 0
            ;;
        *)
            echo -e "${RED}Invalid choice. Please try again.${NC}"
            sleep 2
            ;;
    esac
}

# Display advanced settings menu
show_advanced_menu() {
    clear
    echo -e "$HEADER"

    echo -e "${YELLOW}┌──────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│          ADVANCED SETTINGS           │${NC}"
    echo -e "${YELLOW}└──────────────────────────────────────┘${NC}"
    echo -e "  ${GOLD}1.${NC} Edit Normal Mode Settings"
    echo -e "  ${GOLD}2.${NC} Edit Turbo Mode Settings"
    echo -e "  ${GOLD}3.${NC} Edit Battery Saver Mode Settings"
    echo -e "  ${GOLD}4.${NC} View System Information"
    echo -e "  ${GOLD}5.${NC} View PowerHive Logs"
    echo -e "  ${GOLD}0.${NC} Back to Main Menu"

    echo -e "\n${CYAN}Enter your choice:${NC} "
    read -r choice

    case $choice in
        1)
            edit_mode_settings "normal"
            ;;
        2)
            edit_mode_settings "turbo"
            ;;
        3)
            edit_mode_settings "battery"
            ;;
        4)
            clear
            echo -e "${GOLD}System Information:${NC}"
            echo -e "${CYAN}Device: $(getprop ro.product.model)${NC}"
            echo -e "${CYAN}Android Version: $(getprop ro.build.version.release)${NC}"
            echo -e "${CYAN}Kernel: $(uname -r)${NC}"
            echo -e "${CYAN}CPU: $(grep "model name" /proc/cpuinfo | head -1 | cut -d':' -f2 | sed 's/^ *//')${NC}"
            echo -e "${CYAN}Available CPU Governors:${NC}"
            cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors

            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        5)
            if [ -f "/data/powerhive/powerhive.log" ]; then
                echo -e "${GOLD}PowerHive Log (last 20 entries):${NC}"
                tail -n 20 "/data/powerhive/powerhive.log"
            else
                echo -e "${YELLOW}No log file found${NC}"
            fi

            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        0)
            return
            ;;
        *)
            echo -e "${RED}Invalid choice. Please try again.${NC}"
            sleep 2
            ;;
    esac

    show_advanced_menu
}

# Display backup/restore menu
show_backup_menu() {
    clear
    echo -e "$HEADER"

    echo -e "${YELLOW}┌──────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│        BACKUP & RESTORE MENU         │${NC}"
    echo -e "${YELLOW}└──────────────────────────────────────┘${NC}"
    echo -e "  ${GOLD}1.${NC} Create Backup"
    echo -e "  ${GOLD}2.${NC} Restore from Backup"
    echo -e "  ${GOLD}3.${NC} List Available Backups"
    echo -e "  ${GOLD}0.${NC} Back to Main Menu"

    echo -e "\n${CYAN}Enter your choice:${NC} "
    read -r choice

    case $choice in
        1)
            backup_config
            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        2)
            restore_config
            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        3)
            echo -e "${GOLD}Available Backups:${NC}"
            local backups=($(ls -1 "${BACKUP_DIR}/"*.json 2>/dev/null))

            if [ ${#backups[@]} -eq 0 ]; then
                echo -e "${YELLOW}No backups found${NC}"
            else
                for backup in "${backups[@]}"; do
                    local filename=$(basename "$backup")
                    local date_created=$(date -r "$backup" "+%Y-%m-%d %H:%M:%S")
                    echo -e "${CYAN}$filename${NC} (Created: $date_created)"
                done
            fi

            echo -e "\n${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        0)
            return
            ;;
        *)
            echo -e "${RED}Invalid choice. Please try again.${NC}"
            sleep 2
            ;;
    esac

    show_backup_menu
}

# Display about information
show_about() {
    clear
    echo -e "$HEADER"

    echo -e "${YELLOW}┌──────────────────────────────────────┐${NC}"
    echo -e "${YELLOW}│            ABOUT POWERHIVE           │${NC}"
    echo -e "${YELLOW}└──────────────────────────────────────┘${NC}"
    echo -e "${GOLD}PowerHive v1.0.0${NC}"
    echo -e "A Magisk module for advanced power management"
    echo -e "and system performance control.\n"
    echo -e "${CYAN}Author:${NC} Kelexine"
    echo -e "${CYAN}GitHub:${NC} https://github.com/kelexine/powerhive"
    echo -e "${CYAN}License:${NC} GPLv3"

    echo -e "\n${CYAN}Press Enter to continue...${NC}"
    read -r
}
    # Make script executable
    chmod +x "$MODULE_DIR/system/bin/powerhive"

    log "INFO" "PowerHive main script created successfully"


# Main function
main() {
    check_root
    initialize
    
    # Handle command line arguments
    if [ "$1" = "--smart-mode-service" ]; then
        run_smart_mode_service
        exit 0
    fi
    
    # Main program loop
    while true; do
        show_menu
    done
}

# Start the program
main "$@"
